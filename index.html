<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Drift: Plasticity Trainer</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            background-color: #000;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            width: 600px;
        }
        h1 { margin: 0; font-size: 18px; color: #888; }
        .hud-row { display: flex; justify-content: space-between; margin-top: 10px; font-weight: bold;}
        .stat { background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px; border: 1px solid #333; }
        .inverted-warning {
            color: #ff3333;
            font-weight: bold;
            display: none;
            animation: blink 1s infinite;
        }
        #learning-bar-container {
            width: 100%;
            height: 10px;
            background: #333;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #555;
        }
        #learning-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            transition: width 0.2s;
        }
        @keyframes blink { 50% { opacity: 0; } }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border: 1px solid #fff;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>NEURO-DRIFT</h1>
        <div class="hud-row">
            <div class="stat">LVL: <span id="lvl-display">1</span></div>
            <div class="stat inverted-warning" id="invert-display">⚠ CONTROLS REVERSED ⚠</div>
            <div class="stat">SCORE: <span id="score-display">0</span></div>
        </div>
        <div style="margin-top:5px; font-size: 12px; color: #aaa;">NEURAL ADAPTATION (Pattern Learning)</div>
        <div id="learning-bar-container">
            <div id="learning-bar"></div>
        </div>
    </div>

    <canvas id="gameCanvas" width="600" height="800"></canvas>
    <div id="message">Press Space to Start</div>

    <script>
        /**
         * NEURO-DRIFT ENGINE
         * 
         * Logic:
         * 1. Generates a procedural tunnel.
         * 2. Measures "Adaptation" by calculating the Variance of Error (Player Position vs Center).
         * 3. Low variance over time = Brain has learned the pattern.
         * 4. Triggers level up.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game State
        const state = {
            running: false,
            gameOver: false,
            score: 0,
            level: 1,
            adaptation: 0, // 0 to 100
            inverted: false,
            frames: 0
        };

        // Player Configuration
        const player = {
            x: 300,
            y: 600,
            radius: 8,
            speed: 5,
            dx: 0
        };

        // Path Configuration
        const path = {
            segments: [],
            segmentHeight: 5,
            baseWidth: 200,
            currentWidth: 200,
            noiseOffset: 0,
            speed: 3
        };

        // Neural Calculation metrics
        const metrics = {
            errors: [], // Rolling buffer of distance from center
            historySize: 60, // 1 second at 60fps
            stabilityTimer: 0,
            requiredStabilityTime: 300 // Frames required (5 seconds) of stable play to pass
        };

        // Inputs
        const keys = {
            ArrowLeft: false,
            ArrowRight: false
        };

        // DOM Elements
        const elLevel = document.getElementById('lvl-display');
        const elScore = document.getElementById('score-display');
        const elInvert = document.getElementById('invert-display');
        const elBar = document.getElementById('learning-bar');
        const elMsg = document.getElementById('message');

        // --- Core Logic ---

        function init() {
            window.addEventListener('keydown', e => {
                if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
                if(e.code === 'Space') {
                    if(!state.running) startGame();
                    else if(state.gameOver) resetGame();
                }
            });
            window.addEventListener('keyup', e => {
                if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
            });

            resetGame();
            draw(); // Draw initial static frame
        }

        function resetGame() {
            state.running = false;
            state.gameOver = false;
            state.score = 0;
            state.level = 1;
            state.inverted = false;
            state.adaptation = 0;
            
            // Reset Path
            path.currentWidth = 200;
            path.speed = 3;
            path.segments = [];
            for(let i=0; i < canvas.height / path.segmentHeight + 10; i++) {
                path.segments.push({
                    x: canvas.width/2,
                    w: path.currentWidth
                });
            }

            player.x = canvas.width / 2;
            elMsg.style.display = "block";
            elMsg.innerText = "Press SPACE to Initialize Neural Link";
            updateHUD();
        }

        function startGame() {
            state.running = true;
            state.gameOver = false;
            elMsg.style.display = "none";
            loop();
        }

        function setupLevel(lvl) {
            state.level = lvl;
            // Requirement C: Pairs of levels.
            // Pair 1 (Lvl 1, 2): Difficulty 1. 
            // Pair 2 (Lvl 3, 4): Difficulty 2.
            // Formula: Difficulty increases every Odd level (2n+1).
            
            // Difficulty Base
            const difficultyStep = Math.ceil(lvl / 2); 
            
            // Set Physics
            path.speed = 3 + (difficultyStep * 0.5); // Increase speed slightly
            path.currentWidth = Math.max(60, 200 - (difficultyStep * 20)); // Narrower tunnel
            
            // Set Inversion (Even levels are inverted)
            state.inverted = (lvl % 2 === 0);

            // Reset Metrics for new level
            metrics.stabilityTimer = 0;
            metrics.errors = [];
            state.adaptation = 0;

            updateHUD();
            
            // Visual Flash
            const flashColor = state.inverted ? 'rgba(255, 50, 50, 0.5)' : 'rgba(50, 255, 255, 0.5)';
            ctx.fillStyle = flashColor;
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }

        // --- The "Meticulous" Calculation (Objective B) ---
        function calculatePlasticity() {
            // 1. Find the path segment directly under the player
            // Player Y is fixed at 600.
            // Map 600 to segment index.
            // Segments move down, so we look at index based on Y.
            // Actually, we render from bottom up or top down? Let's look at updatePath.
            // Simplified: The segment at player.y.
            
            // We'll iterate segments to find the one at player.y
            // But since they are uniform height, we can estimate.
            // However, easiest way: The segment at index ~ (player.y / height) isn't static because array shifts.
            // Let's just find the segment in the array that corresponds to Y=600.
            const playerSegIndex = Math.floor(player.y / path.segmentHeight); 
            // Note: Since we unshift/pop, the array indices map to screen Y. 
            // Let's say index 0 is at -height, and index N is at Height.
            // We will simplify: The logic updates segments, index 0 is top of screen.
            // player.y is 600. segmentHeight is 5. Index = 120.
            
            const currentSeg = path.segments[120]; 

            if(!currentSeg) return;

            // 2. Calculate Deviation
            const center = currentSeg.x;
            const deviation = Math.abs(player.x - center);
            const normalizedError = deviation / (currentSeg.w / 2); // 0 = center, 1 = edge

            // 3. Add to rolling history
            metrics.errors.push(normalizedError);
            if(metrics.errors.length > metrics.historySize) metrics.errors.shift();

            // 4. Calculate Variance/Stability
            // We want low error average AND low jitter.
            const sum = metrics.errors.reduce((a, b) => a + b, 0);
            const avg = sum / metrics.errors.length;

            // Thresholds:
            // To prove "Learning", the player must be reasonably centered (avg < 0.4)
            // And consistent.
            
            if (metrics.errors.length === metrics.historySize && avg < 0.4) {
                // We are in the "Zone"
                metrics.stabilityTimer++;
            } else {
                // Lost focus
                if(metrics.stabilityTimer > 0) metrics.stabilityTimer -= 2; // Decay
                if(metrics.stabilityTimer < 0) metrics.stabilityTimer = 0;
            }

            // 5. Update Adaptation Meter
            // Max timer depends on difficulty. Harder levels require longer proof of mastery.
            const targetTime = metrics.requiredStabilityTime + (state.level * 30);
            state.adaptation = Math.min(100, (metrics.stabilityTimer / targetTime) * 100);

            if(state.adaptation >= 100) {
                levelUp();
            }
        }

        function levelUp() {
            state.level++;
            setupLevel(state.level);
            // Reward
            state.score += 1000;
        }

        // --- Game Loop ---

        function update() {
            if(state.gameOver) return;
            state.frames++;

            // 1. Player Movement
            let move = 0;
            if(keys.ArrowLeft) move = -player.speed;
            if(keys.ArrowRight) move = player.speed;

            // Apply Inversion
            if(state.inverted) move = -move;

            player.x += move;

            // 2. Update Path
            // Scroll existing segments down? No, we add to top, remove bottom? 
            // Usually simpler to shift array: Add new at index 0 (top), remove last (bottom).
            
            // Noise generation for winding path
            path.noiseOffset += 0.05 * (1 + (state.level * 0.1));
            const wave = Math.sin(path.noiseOffset) * (canvas.width * 0.35); // Winding amount
            const centerX = (canvas.width / 2) + wave;

            // Smooth Clamp
            let newX = centerX;
            if(newX < path.currentWidth/2) newX = path.currentWidth/2;
            if(newX > canvas.width - path.currentWidth/2) newX = canvas.width - path.currentWidth/2;

            path.segments.unshift({ x: newX, w: path.currentWidth });
            if(path.segments.length > (canvas.height / path.segmentHeight) + 20) {
                path.segments.pop();
            }

            // 3. Collision Detection
            // Get segment at player Y
            const playerSeg = path.segments[Math.floor(player.y / path.segmentHeight)];
            if(playerSeg) {
                const leftWall = playerSeg.x - (playerSeg.w / 2);
                const rightWall = playerSeg.x + (playerSeg.w / 2);

                // Collision
                if (player.x - player.radius < leftWall || player.x + player.radius > rightWall) {
                    gameOver();
                }
            }

            // 4. Logic Updates
            state.score++;
            calculatePlasticity();
            updateHUD();
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Path
            ctx.beginPath();
            
            // We draw filled polygons connecting the segments
            // Left Wall
            ctx.fillStyle = state.inverted ? '#331111' : '#112233'; // Red tint if inverted
            ctx.moveTo(0, 0);
            
            // Iterate segments to draw left bank
            for(let i=0; i<path.segments.length; i++) {
                const s = path.segments[i];
                const py = i * path.segmentHeight;
                const lx = s.x - (s.w / 2);
                ctx.lineTo(lx, py);
            }
            ctx.lineTo(0, canvas.height);
            ctx.fill();

            // Right Wall
            ctx.beginPath();
            ctx.moveTo(canvas.width, 0);
            for(let i=0; i<path.segments.length; i++) {
                const s = path.segments[i];
                const py = i * path.segmentHeight;
                const rx = s.x + (s.w / 2);
                ctx.lineTo(rx, py);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();

            // Draw Center Line (Visual Guide)
            ctx.strokeStyle = state.inverted ? '#550000' : '#003344';
            ctx.beginPath();
            for(let i=0; i<path.segments.length; i++) {
                const s = path.segments[i];
                const py = i * path.segmentHeight;
                if(i===0) ctx.moveTo(s.x, py);
                else ctx.lineTo(s.x, py);
            }
            ctx.stroke();

            // Draw Player
            ctx.fillStyle = state.inverted ? '#ffaa00' : '#00ffff';
            ctx.shadowBlur = 15;
            ctx.shadowColor = ctx.fillStyle;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw "Learning Zone" indicators
            // If learning is high, make player glow white
            if(state.adaptation > 80) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateHUD() {
            elScore.innerText = state.score;
            elLevel.innerText = state.level;
            elInvert.style.display = state.inverted ? "block" : "none";
            elBar.style.width = state.adaptation + "%";
            
            // Color bar based on progress
            if(state.adaptation > 90) elBar.style.background = "#00ff00";
            else elBar.style.background = "linear-gradient(90deg, #00d2ff, #3a7bd5)";
        }

        function gameOver() {
            state.gameOver = true;
            state.running = false;
            elMsg.innerHTML = `NEURAL LINK BROKEN<br><span style="font-size:16px">Level Reached: ${state.level}</span><br><br>Press SPACE to Retry`;
            elMsg.style.display = "block";
        }

        function loop() {
            if(state.running) {
                update();
                draw();
                requestAnimationFrame(loop);
            }
        }

        // Initialize
        init();

    </script>
</body>
</html>
