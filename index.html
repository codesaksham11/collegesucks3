<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro-Drift J7 Patch</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas { display: block; background-color: #000; }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
            pointer-events: none;
            text-align: center;
        }
        h1 { margin: 0; font-size: 16px; color: #666; letter-spacing: 2px; }
        .hud-row { 
            display: flex; justify-content: space-between; margin-top: 5px; 
            font-weight: bold; font-size: 14px;
        }
        .stat { 
            background: rgba(0,0,0,0.6); padding: 4px 8px; 
            border-radius: 4px; border: 1px solid #333; 
        }
        .inverted-warning {
            color: #ff3333; font-weight: bold; display: none;
            animation: blink 0.8s infinite; font-size: 12px; padding-top: 6px;
        }
        #learning-bar-container {
            width: 80%; height: 6px; background: #222; margin: 8px auto 0;
            border-radius: 3px; overflow: hidden; border: 1px solid #444;
        }
        #learning-bar {
            width: 0%; height: 100%;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            transition: width 0.2s;
        }
        .touch-hint {
            position: absolute; bottom: 20px; width: 40%; height: 50px;
            border: 2px dashed rgba(255,255,255,0.1); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.2); font-size: 12px; pointer-events: none;
        }
        #left-hint { left: 5%; }
        #right-hint { right: 5%; }
        @keyframes blink { 50% { opacity: 0; } }
        
        #message {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px; background: rgba(0,0,0,0.9);
            padding: 20px; border: 1px solid #fff;
            display: none; text-align: center;
            width: 85%; border-radius: 8px;
            box-shadow: 0 0 15px #000; z-index: 10;
        }
        .btn-ready {
            margin-top: 15px; padding: 10px 20px;
            background: #222; border: 1px solid #fff;
            color: #fff; display: inline-block;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>NEURO-DRIFT</h1>
        <div class="hud-row">
            <div class="stat">LVL <span id="lvl-display">1</span></div>
            <div class="inverted-warning" id="invert-display">⚠ REVERSED ⚠</div>
            <div class="stat"><span id="score-display">0</span></div>
        </div>
        <div id="learning-bar-container">
            <div id="learning-bar"></div>
        </div>
    </div>

    <div id="left-hint" class="touch-hint">LEFT</div>
    <div id="right-hint" class="touch-hint">RIGHT</div>

    <canvas id="gameCanvas"></canvas>
    <div id="message">TAP TO START</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game State
        const state = {
            running: false,
            waitingForTap: false, // NEW: Specific state for level transitions
            gameOver: false,
            score: 0,
            level: 1,
            adaptation: 0, 
            inverted: false,
            frames: 0
        };

        const player = { x: 0, y: 0, radius: 10, speed: 0, baseSpeedMult: 0.015 };
        const path = {
            segments: [], segmentHeight: 10, 
            baseWidthRatio: 0.5, currentWidth: 0, 
            noiseOffset: 0, speed: 4
        };
        const metrics = { errors: [], historySize: 45, stabilityTimer: 0, requiredStabilityTime: 300 };
        const inputs = { left: false, right: false };

        // UI
        const elLevel = document.getElementById('lvl-display');
        const elScore = document.getElementById('score-display');
        const elInvert = document.getElementById('invert-display');
        const elBar = document.getElementById('learning-bar');
        const elMsg = document.getElementById('message');

        // --- Touch Handling ---
        function handleTouch(e) {
            e.preventDefault();
            inputs.left = false;
            inputs.right = false;

            const halfWidth = canvas.width / 2;
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].clientX < halfWidth) inputs.left = true;
                else inputs.right = true;
            }

            // Logic for Tapping based on State
            if (e.type === 'touchstart') {
                if (state.gameOver) {
                    resetGame(); // Restart from Lvl 1
                } 
                else if (state.waitingForTap) {
                    resumeGame(); // Continue to next Level
                }
                else if (!state.running) {
                    startGame(); // Initial Start
                }
            }
        }

        window.addEventListener('touchstart', handleTouch, { passive: false });
        window.addEventListener('touchmove', handleTouch, { passive: false });
        window.addEventListener('touchend', handleTouch, { passive: false });

        // --- Core Logic ---

        function init() {
            resetGame();
            state.running = false; // Ensure it starts paused
            draw();
            elMsg.style.display = "block";
            elMsg.innerHTML = "NEURO-DRIFT<br><span style='font-size:14px; color:#aaa'>Left Hand Trainer</span><br><br>TAP TO START";
        }

        function resetGame() {
            state.running = false;
            state.waitingForTap = false;
            state.gameOver = false;
            state.score = 0;
            state.level = 1;
            state.inverted = false;
            state.adaptation = 0;
            
            player.x = canvas.width / 2;
            player.y = canvas.height * 0.75;
            player.speed = canvas.width * player.baseSpeedMult;

            path.currentWidth = canvas.width * path.baseWidthRatio;
            path.segments = [];
            for(let i=0; i < canvas.height / path.segmentHeight + 5; i++) {
                path.segments.push({ x: canvas.width/2, w: path.currentWidth });
            }

            metrics.stabilityTimer = 0;
            metrics.errors = [];
            updateHUD();
        }

        function startGame() {
            state.running = true;
            elMsg.style.display = "none";
            loop();
        }

        function resumeGame() {
            state.waitingForTap = false;
            state.running = true;
            elMsg.style.display = "none";
            loop();
        }

        function setupLevel(lvl) {
            state.level = lvl;
            state.inverted = (lvl % 2 === 0);
            
            const difficultyStep = Math.ceil(lvl / 2);
            const widthRatio = Math.max(0.2, 0.5 - (difficultyStep * 0.05));
            path.currentWidth = canvas.width * widthRatio;
            path.speed = 4 + (difficultyStep * 0.5); 

            metrics.stabilityTimer = 0;
            metrics.errors = []; // Clear history so we don't level up instantly again
            state.adaptation = 0;
            
            updateHUD();
        }

        function levelUp() {
            // 1. Pause Logic
            state.running = false; 
            state.waitingForTap = true;

            // 2. Setup Next Level Physics
            state.level++;
            setupLevel(state.level);

            // 3. Show Interstitial Screen
            let html = `<strong>LEVEL ${state.level}</strong><br><br>`;
            
            if(state.inverted) {
                html += `<span style="color:#ff4444; font-size:18px; border:1px solid #ff4444; padding:5px;">⚠ CONTROLS REVERSED ⚠</span>`;
                html += `<br><br><span style="font-size:14px; color:#aaa">Left is Right<br>Right is Left</span>`;
            } else {
                html += `<span style="color:#44ffff; font-size:18px; border:1px solid #44ffff; padding:5px;">CONTROLS NORMALIZED</span>`;
                html += `<br><br><span style="font-size:14px; color:#aaa">Back to standard input</span>`;
            }

            html += `<br><br><div class='btn-ready'>TAP TO CONTINUE</div>`;

            elMsg.innerHTML = html;
            elMsg.style.display = "block";
            
            // Note: We do NOT call loop() here. We wait for touchstart.
        }

        function calculatePlasticity() {
            const playerIndex = Math.floor(player.y / path.segmentHeight);
            const currentSeg = path.segments[playerIndex];
            if(!currentSeg) return;

            const center = currentSeg.x;
            const deviation = Math.abs(player.x - center);
            const normalizedError = deviation / (currentSeg.w / 2); 

            metrics.errors.push(normalizedError);
            if(metrics.errors.length > metrics.historySize) metrics.errors.shift();

            const sum = metrics.errors.reduce((a, b) => a + b, 0);
            const avg = sum / metrics.errors.length;

            if (metrics.errors.length === metrics.historySize && avg < 0.55) {
                metrics.stabilityTimer++;
            } else {
                if(metrics.stabilityTimer > 0) metrics.stabilityTimer -= 2; 
                if(metrics.stabilityTimer < 0) metrics.stabilityTimer = 0;
            }

            const targetTime = metrics.requiredStabilityTime + (state.level * 60);
            state.adaptation = Math.min(100, (metrics.stabilityTimer / targetTime) * 100);

            if(state.adaptation >= 100) {
                levelUp();
            }
        }

        function update() {
            if(state.gameOver || state.waitingForTap) return;

            // Movement
            let move = 0;
            if(inputs.left) move = -player.speed;
            if(inputs.right) move = player.speed;

            if(state.inverted) move = -move;

            player.x += move;

            // Path Gen
            path.noiseOffset += 0.05 * (1 + (state.level * 0.05));
            const wave = Math.sin(path.noiseOffset) * (canvas.width * 0.35); 
            let centerX = (canvas.width / 2) + wave;

            const limit = path.currentWidth/2 + 10;
            if(centerX < limit) centerX = limit;
            if(centerX > canvas.width - limit) centerX = canvas.width - limit;

            path.segments.unshift({ x: centerX, w: path.currentWidth });
            
            if(path.segments.length * path.segmentHeight > canvas.height + 50) {
                path.segments.pop();
            }

            // Collision
            const playerIndex = Math.floor(player.y / path.segmentHeight);
            const seg = path.segments[playerIndex];
            
            if(seg) {
                const halfW = seg.w / 2;
                if (player.x - player.radius < seg.x - halfW || 
                    player.x + player.radius > seg.x + halfW) {
                    gameOver();
                }
            }

            state.score++;
            calculatePlasticity();
            updateHUD();
        }

        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Banks
            ctx.beginPath();
            ctx.fillStyle = state.inverted ? '#422' : '#223';
            ctx.moveTo(0, 0);
            for(let i=0; i<path.segments.length; i++) {
                const s = path.segments[i];
                ctx.lineTo(s.x - (s.w/2), i * path.segmentHeight);
            }
            ctx.lineTo(0, canvas.height);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(canvas.width, 0);
            for(let i=0; i<path.segments.length; i++) {
                const s = path.segments[i];
                ctx.lineTo(s.x + (s.w/2), i * path.segmentHeight);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();

            // Center Line
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            for(let i=0; i<path.segments.length; i++) {
                if(i%2===0) {
                    const s = path.segments[i];
                    ctx.lineTo(s.x, i * path.segmentHeight);
                }
            }
            ctx.stroke();

            // Player
            ctx.fillStyle = state.inverted ? '#f80' : '#0ff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();

            if(state.adaptation > 50) {
                ctx.strokeStyle = `rgba(255,255,255,${(state.adaptation-50)/50})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateHUD() {
            if(state.frames % 5 === 0) {
                elScore.innerText = state.score;
                elLevel.innerText = state.level;
                elInvert.style.display = state.inverted ? "block" : "none";
                elBar.style.width = state.adaptation + "%";
                if(state.adaptation > 90) elBar.style.background = "#0f0";
                else elBar.style.background = "linear-gradient(90deg, #00d2ff, #3a7bd5)";
            }
            state.frames++;
        }

        function gameOver() {
            state.gameOver = true;
            state.running = false;
            elMsg.innerHTML = `NEURAL LINK BROKEN<br>LVL: ${state.level}<br><br>TAP TO RETRY`;
            elMsg.style.display = "block";
        }

        function loop() {
            if(state.running) {
                update();
                draw();
                requestAnimationFrame(loop);
            }
        }

        init();

    </script>
</body>
    </html>
