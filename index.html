<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro-Mirror: Plasticity Trainer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Disables browser zooming/scrolling */
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            
            /* ADD THIS LINE BELOW */
            z-index: 20; 
        }

        .hud {
            padding: 20px;
            color: #00ffcc;
            text-shadow: 0 0 5px #00ffcc;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
        }

        .center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #00ffcc;
            border-radius: 10px;
            display: none; /* Hidden by default */
            pointer-events: auto;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
        }

        /* distinct coloring for reversed mode */
        .reversed-theme {
            color: #ff4444 !important;
            text-shadow: 0 0 5px #ff4444 !important;
            border-color: #ff4444 !important;
        }
        
        button {
            background: transparent;
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        button:active {
            background: #00ffcc;
            color: black;
        }

        .split-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            z-index: 10;
        }
        .touch-zone {
            width: 50%;
            height: 100%;
            /* semi-transparent debug check */
            /* background: rgba(255,0,0,0.1); */ 
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Invisible touch zones for controls -->
    <div class="split-screen">
        <div id="leftZone" class="touch-zone"></div>
        <div id="rightZone" class="touch-zone"></div>
    </div>

    <div id="ui-layer">
        <div class="hud" id="hud">
            <span id="levelDisplay">LEVEL 1</span>
            <span id="modeDisplay">NORMAL CONTROL</span>
        </div>
        <div class="controls-hint" id="controlHint">
            TAP LEFT / RIGHT
        </div>
    </div>

    <div id="startScreen" class="center-msg" style="display: block;">
        <h1 style="margin:0 0 10px 0;">NEURO-MIRROR</h1>
        <p>Phase 1: Learn the Pattern.</p>
        <p>Phase 2: Pattern Repeats, Controls FLIP.</p>
        <button onclick="startGame()">INITIATE</button>
    </div>

    <div id="gameOverScreen" class="center-msg">
        <h2 id="goTitle">SYNC FAILURE</h2>
        <p id="goReason"></p>
        <button onclick="retryLevel()">RETRY LEVEL</button>
    </div>

    <div id="successScreen" class="center-msg">
        <h2>PATHWAY FORMED</h2>
        <p>Preparing Neural Switch...</p>
        <p id="nextModeText"></p>
        <button onclick="nextLevel()">PROCEED</button>
    </div>

    <script>
        /**
         * NEUROPLASTICITY GAME ENGINE
         * Meets objectives: A (Controls), B (Pattern Learning), C (Paired Levels), D (State Reset), E (Mobile)
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- Game Configuration ---
        let screenW, screenH;
        const BASE_SPEED = 4;
        const PLAYER_SIZE = 20;
        const LEVEL_LENGTH = 2000; // Distance to travel to beat level

        // --- State Management ---
        let gameState = {
            level: 1, // 1=Normal, 2=Flipped (Same Map), 3=Normal(Harder), 4=Flipped(Same Map as 3)
            isPlaying: false,
            distance: 0,
            speed: BASE_SPEED,
            isReversed: false,
            seed: 1, // Seed for map generation
            pairSeed: 1, // Determines the seed for the current pair (1&2 share seed, 3&4 share seed)
            playerX: 0,
            inputLeft: false,
            inputRight: false
        };

        let obstacles = [];
        let particles = []; // For death effect

        // --- Resize Handling ---
        function resize() {
            screenW = window.innerWidth;
            screenH = window.innerHeight;
            canvas.width = screenW;
            canvas.height = screenH;
            // Recenter player on resize if idle
            if(!gameState.isPlaying) gameState.playerX = screenW / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling (Mobile & Mouse) ---
        const leftZone = document.getElementById('leftZone');
        const rightZone = document.getElementById('rightZone');

        function setInput(side, active) {
            if (side === 'left') gameState.inputLeft = active;
            if (side === 'right') gameState.inputRight = active;
        }

        // Touch Events
        leftZone.addEventListener('touchstart', (e) => { e.preventDefault(); setInput('left', true); });
        leftZone.addEventListener('touchend', (e) => { e.preventDefault(); setInput('left', false); });
        rightZone.addEventListener('touchstart', (e) => { e.preventDefault(); setInput('right', true); });
        rightZone.addEventListener('touchend', (e) => { e.preventDefault(); setInput('right', false); });

        // Mouse Events (for testing on desktop)
        leftZone.addEventListener('mousedown', () => setInput('left', true));
        leftZone.addEventListener('mouseup', () => setInput('left', false));
        rightZone.addEventListener('mousedown', () => setInput('right', true));
        rightZone.addEventListener('mouseup', () => setInput('right', false));

        // --- Pseudo Random Number Generator (Seeded) ---
        // Crucial for Objective D: Reproducing the exact level pattern
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // --- Game Logic ---

        function generateLevel() {
            obstacles = [];
            // Calculate difficulty based on Level Pair (Level 1,2 = Diff 1 | Level 3,4 = Diff 2)
            let difficultyIndex = Math.ceil(gameState.level / 2);
            
            // Objective C: Same hardness in paired levels (shared seed), harder in next pair
            let currentSeed = gameState.pairSeed; 
            let rng = mulberry32(currentSeed); // Reset RNG to seed

            let numberOfObstacles = 15 + (difficultyIndex * 5); // Increase density
            gameState.speed = BASE_SPEED + (difficultyIndex * 0.5); // Increase speed

            for(let i=0; i<numberOfObstacles; i++) {
                // Ensure obstacles are spread out over the level duration
                let yPos = - (500 + (i * (LEVEL_LENGTH / numberOfObstacles) * 0.8) + (rng() * 200));
                let width = screenW * (0.3 + (rng() * 0.3)); // Random width
                let xPos = rng() * (screenW - width);
                
                obstacles.push({
                    x: xPos,
                    y: yPos,
                    w: width,
                    h: 30,
                    passed: false
                });
            }
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            resetLevelState();
            gameState.isPlaying = true;
            loop();
        }

        function nextLevel() {
            document.getElementById('successScreen').style.display = 'none';
            gameState.level++;
            
            // Check Objective C: Is this an even level (Flipped) or odd (New Pair)?
            if (gameState.level % 2 === 0) {
                // Even Level: Same pair, flip controls
                gameState.isReversed = true;
                // Keep PairSeed the same!
            } else {
                // Odd Level: New pair, harder, normal controls
                gameState.isReversed = false;
                gameState.pairSeed = Math.floor(Math.random() * 10000); // New seed for new map
            }

            updateHUD();
            resetLevelState(); // Objective D: Start from initial point
            gameState.isPlaying = true;
            loop();
        }

        function retryLevel() {
            document.getElementById('gameOverScreen').style.display = 'none';
            resetLevelState(); // Objective D: Just reset state, don't change level/seed/mode
            gameState.isPlaying = true;
            loop();
        }

        function resetLevelState() {
            gameState.playerX = screenW / 2;
            gameState.distance = 0;
            gameState.inputLeft = false;
            gameState.inputRight = false;
            generateLevel(); // Re-runs generation with CURRENT settings (preserves seed/controls)
            particles = [];
        }

        function updateHUD() {
            const hud = document.getElementById('hud');
            const lvl = document.getElementById('levelDisplay');
            const mode = document.getElementById('modeDisplay');
            const hint = document.getElementById('controlHint');

            lvl.innerText = `LEVEL ${gameState.level}`;
            
            if(gameState.isReversed) {
                mode.innerText = "CONTROLS: FLIPPED";
                hint.innerText = "WARNING: LEFT IS RIGHT | RIGHT IS LEFT";
                hud.classList.add('reversed-theme');
                document.getElementById('startScreen').classList.add('reversed-theme');
            } else {
                mode.innerText = "CONTROLS: NORMAL";
                hint.innerText = "TAP LEFT / RIGHT";
                hud.classList.remove('reversed-theme');
                document.getElementById('startScreen').classList.remove('reversed-theme');
            }
        }

        function triggerGameOver() {
            gameState.isPlaying = false;
            // Create explosion
            for(let i=0; i<20; i++) {
                particles.push({
                    x: gameState.playerX,
                    y: screenH - 100,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0
                });
            }
            
            setTimeout(() => {
                document.getElementById('gameOverScreen').style.display = 'block';
                document.getElementById('goReason').innerText = gameState.isReversed ? 
                    "Brain Confusion Detected." : "Reflex Failure.";
            }, 500);
        }

        function triggerWin() {
            gameState.isPlaying = false;
            document.getElementById('successScreen').style.display = 'block';
            let nextIsReversed = (gameState.level + 1) % 2 === 0;
            document.getElementById('nextModeText').innerText = nextIsReversed ? 
                "CAUTION: CONTROLS WILL BE REVERSED" : "RETURNING TO NORMAL SYNC";
        }

        // --- Physics & Drawing ---

        function update() {
            if (!gameState.isPlaying) return;

            // Movement Logic
            // Objective A & B: The Core Mechanic
            let moveLeft = false;
            let moveRight = false;

            if (gameState.isReversed) {
                // FLIPPED: Input Left moves Right
                if (gameState.inputLeft) moveRight = true;
                if (gameState.inputRight) moveLeft = true;
            } else {
                // NORMAL
                if (gameState.inputLeft) moveLeft = true;
                if (gameState.inputRight) moveRight = true;
            }

            const speedX = 6;
            if (moveLeft) gameState.playerX -= speedX;
            if (moveRight) gameState.playerX += speedX;

            // Boundaries
            if (gameState.playerX < PLAYER_SIZE) gameState.playerX = PLAYER_SIZE;
            if (gameState.playerX > screenW - PLAYER_SIZE) gameState.playerX = screenW - PLAYER_SIZE;

            // Move Obstacles (Simulate forward movement)
            gameState.distance += gameState.speed;
            
            let allPassed = true;

            for(let obs of obstacles) {
                obs.y += gameState.speed;

                // Collision Detection
                // Simple AABB
                if (obs.y + obs.h > screenH - 100 - PLAYER_SIZE && 
                    obs.y < screenH - 100 + PLAYER_SIZE) {
                    
                    if (gameState.playerX + PLAYER_SIZE > obs.x && 
                        gameState.playerX - PLAYER_SIZE < obs.x + obs.w) {
                        triggerGameOver();
                    }
                }

                if (obs.y < screenH + 100) allPassed = false;
            }

            // Objective B: "When the brain has learnt the pattern"
            // We measure this by level completion. If they finish the obstacles, they learnt it.
            if (allPassed && gameState.distance > LEVEL_LENGTH) {
                triggerWin();
            }
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, screenW, screenH);

            // Draw Grid/Tunnel effect (Neuroplasticity visual)
            ctx.strokeStyle = gameState.isReversed ? 'rgba(255, 68, 68, 0.1)' : 'rgba(0, 255, 204, 0.1)';
            ctx.lineWidth = 2;
            
            let offset = gameState.distance % 100;
            for(let i=0; i<screenH; i+=100) {
                ctx.beginPath();
                ctx.moveTo(0, i + offset);
                ctx.lineTo(screenW, i + offset);
                ctx.stroke();
            }
            // Vertical perspective lines
            ctx.beginPath(); ctx.moveTo(screenW/3, 0); ctx.lineTo(0, screenH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(screenW*2/3, 0); ctx.lineTo(screenW, screenH); ctx.stroke();

            // Draw Player
            ctx.fillStyle = gameState.isReversed ? '#ff4444' : '#00ffcc';
            ctx.shadowBlur = 15;
            ctx.shadowColor = ctx.fillStyle;
            
            ctx.beginPath();
            ctx.arc(gameState.playerX, screenH - 100, PLAYER_SIZE, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Obstacles
            ctx.fillStyle = '#ffffff';
            for(let obs of obstacles) {
                if(obs.y > -100 && obs.y < screenH) {
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                }
            }

            // Draw Progress Bar
            let progress = Math.min(gameState.distance / LEVEL_LENGTH, 1);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, screenH - 5, screenW, 5);
            ctx.fillStyle = gameState.isReversed ? '#ff4444' : '#00ffcc';
            ctx.fillRect(0, screenH - 5, screenW * progress, 5);

            // Particles
            for(let p of particles) {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
                ctx.fillRect(p.x, p.y, 4, 4);
            }
        }

        function loop() {
            if(gameState.isPlaying || particles.length > 0) {
                update();
                draw();
                if(gameState.isPlaying) requestAnimationFrame(loop);
                else if (particles.length > 0 && particles[0].life > 0) requestAnimationFrame(loop); // Continue drawing explosion
            }
        }

        // Initialize UI
        updateHUD();

    </script>
</body>
    </html>
