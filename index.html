<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuro-Walker: Plasticity Trainer</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --text-color: #e2e8f0;
            --accent-normal: #38bdf8;
            --accent-flipped: #f43f5e;
            --wall-color: #334155;
            --path-color: #1e293b;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid var(--wall-color);
        }

        canvas {
            display: block;
            background-color: var(--path-color);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(15, 23, 42, 0.9);
            padding: 20px;
            border: 1px solid var(--text-color);
            display: none;
        }

        .mode-indicator {
            padding: 4px 8px;
            border-radius: 4px;
        }

        .mode-normal { background-color: var(--accent-normal); color: #000; }
        .mode-flipped { background-color: var(--accent-flipped); color: #fff; }

        /* Scanline effect for retro feel/low resource look */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div class="scanlines"></div>
        
        <div id="ui-layer">
            <div class="hud-top">
                <span id="level-display">Level: 1</span>
                <span id="mode-display" class="mode-indicator mode-normal">Mode: MOTOR ACQUISITION</span>
            </div>
        </div>

        <div id="status-msg">
            <h2 id="msg-title">NEURAL PATHWAY FORMED</h2>
            <p id="msg-body">Initiating control reversal...</p>
            <p style="font-size: 0.8em; color: #aaa;">Press SPACE to Continue</p>
        </div>
    </div>

    <script>
        /**
         * NEURO-WALKER GAME ENGINE
         * Optimized for pattern learning and control inversion.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusBox = document.getElementById('status-msg');
        const msgTitle = document.getElementById('msg-title');
        const msgBody = document.getElementById('msg-body');
        const modeDisplay = document.getElementById('mode-display');
        const levelDisplay = document.getElementById('level-display');

        // Game State
        const STATE = {
            level: 1,           // The actual difficulty level (size of maze)
            isFlipped: false,   // false = Normal Controls, true = Inverted Controls
            isPlaying: false,
            gridSize: 20,       // Size of one tile in pixels
            cols: 0,
            rows: 0
        };

        // Entities
        const player = { x: 0, y: 0, color: '#38bdf8' };
        const goal = { x: 0, y: 0, color: '#4ade80' };
        
        // Map Data (1 = Wall, 0 = Path)
        let map = [];
        // We store the seed or the map itself to ensure the Flipped level is IDENTICAL
        let currentMapLayout = []; 

        // Input Tracking
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

        // --- CORE LOGIC: Maze Generation (Recursive Backtracker) ---
        // This ensures a solvable path exists.
        function generateMaze(difficulty) {
            // Difficulty determines grid size
            // Level 1: 15 cols, Level 2: 19 cols, etc.
            const baseSize = 15;
            const size = baseSize + (difficulty * 2);
            
            STATE.cols = size;
            STATE.rows = size;
            
            // Adjust canvas size scaling if needed, or keep canvas fixed and scale tiles
            // Here we adjust tile size to fit the canvas to keep rendering "normal"
            STATE.gridSize = Math.floor(canvas.width / STATE.cols);
            
            // Initialize Grid with Walls
            let grid = [];
            for(let y=0; y<STATE.rows; y++) {
                let row = [];
                for(let x=0; x<STATE.cols; x++) {
                    row.push(1);
                }
                grid.push(row);
            }

            // Carver
            const dirs = [
                {x:0, y:-2}, {x:0, y:2}, {x:-2, y:0}, {x:2, y:0}
            ];
            
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function carve(x, y) {
                grid[y][x] = 0;
                shuffle(dirs);
                
                for(let d of dirs) {
                    let nx = x + d.x;
                    let ny = y + d.y;
                    
                    if(nx > 0 && nx < STATE.cols-1 && ny > 0 && ny < STATE.rows-1 && grid[ny][nx] === 1) {
                        grid[y + d.y/2][x + d.x/2] = 0; // Knock down wall between
                        carve(nx, ny);
                    }
                }
            }

            // Start carving from (1,1)
            carve(1, 1);
            
            // Set Goal at bottom right-ish
            // Find a valid empty spot near bottom right
            let gx = STATE.cols - 2;
            let gy = STATE.rows - 2;
            while(grid[gy][gx] === 1) {
                gx--;
                if(gx < STATE.cols/2) { gx = STATE.cols-2; gy--; }
            }
            goal.x = gx;
            goal.y = gy;

            // Set Player Start
            player.x = 1;
            player.y = 1;

            return grid;
        }

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
            if(e.code === "Space" && !STATE.isPlaying) {
                resumeGame();
            }
        });
        window.addEventListener('keyup', (e) => {
            if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
        });

        function handleInput() {
            if (!STATE.isPlaying) return;

            // Movement Delay/Speed limiter for controlled movement
            // We use a simple cooldown or just per-frame movement.
            // For a maze, discrete movement (tile by tile) or smooth? 
            // Smooth is harder for control flipping. Let's do semi-smooth with collision.
            
            const speed = 0.15; // sub-pixels per frame
            
            let dx = 0;
            let dy = 0;

            if (keys.ArrowUp) dy -= 1;
            if (keys.ArrowDown) dy += 1;
            if (keys.ArrowLeft) dx -= 1;
            if (keys.ArrowRight) dx += 1;

            // --- THE NEUROPLASTICITY CORE ---
            // If Level is Flipped, reverse inputs
            if (STATE.isFlipped) {
                dx = -dx;
                dy = -dy;
            }

            movePlayer(dx * speed, dy * speed);
        }

        function movePlayer(dx, dy) {
            // Proposed new position
            let nextX = player.x + dx;
            let nextY = player.y + dy;

            // Collision Detection (AABB vs Grid Walls)
            // Player size is slightly smaller than tile to fit through
            const size = 0.7; 
            const offset = (1 - size) / 2;

            // Check corners of the player square against the map
            if (!checkCollision(nextX + offset, player.y + offset, size) && 
                !checkCollision(nextX + offset + size, player.y + offset, size) &&
                !checkCollision(nextX + offset, player.y + offset + size, size) &&
                !checkCollision(nextX + offset + size, player.y + offset + size, size)) {
                player.x = nextX;
            }

            if (!checkCollision(player.x + offset, nextY + offset, size) && 
                !checkCollision(player.x + offset + size, nextY + offset, size) &&
                !checkCollision(player.x + offset, nextY + offset + size, size) &&
                !checkCollision(player.x + offset + size, nextY + offset + size, size)) {
                player.y = nextY;
            }
            
            checkWin();
        }

        function checkCollision(x, y) {
            let gridX = Math.floor(x);
            let gridY = Math.floor(y);
            
            // Out of bounds
            if (gridY < 0 || gridY >= STATE.rows || gridX < 0 || gridX >= STATE.cols) return true;
            
            // Wall
            return currentMapLayout[gridY][gridX] === 1;
        }

        function checkWin() {
            // Distance to goal
            let dist = Math.hypot(player.x - goal.x, player.y - goal.y);
            if (dist < 0.5) {
                levelComplete();
            }
        }

        // --- GAME FLOW ---

        function initGame() {
            // Initial load
            loadLevelPair(1);
            STATE.isPlaying = true;
            render();
        }

        function loadLevelPair(levelIndex) {
            STATE.level = levelIndex;
            STATE.isFlipped = false; // Start normal
            currentMapLayout = generateMaze(STATE.level);
            updateUI();
        }

        function levelComplete() {
            STATE.isPlaying = false;
            
            if (!STATE.isFlipped) {
                // Phase 1 Complete: Brain has learned the pattern.
                // Trigger Phase 2: Switch Flip, Same Level.
                msgTitle.innerText = "PATTERN ACQUIRED";
                msgBody.innerText = "The brain has mapped the spatial data.\n\nActivating Neuro-Plasticity Switch.\nControls are now FLIPPED.\nNavigate the SAME path.";
                statusBox.style.display = 'block';
                
                // Set state for next resume
                STATE.isFlipped = true;
                
            } else {
                // Phase 2 Complete: Brain has mastered the inversion.
                // Trigger Phase 3: New Level, Reset Switch.
                msgTitle.innerText = "NEURAL ADAPTATION COMPLETE";
                msgBody.innerText = "Synaptic connection strengthened.\n\nPreparing next complexity tier.\nControls resetting to NORMAL.";
                statusBox.style.display = 'block';

                // Prepare next level
                STATE.level++;
                STATE.isFlipped = false; // Reset to normal for new map
            }
        }

        function resumeGame() {
            statusBox.style.display = 'none';
            STATE.isPlaying = true;
            
            if(STATE.isFlipped) {
                // Reset player to start, Keep Map same
                player.x = 1; 
                player.y = 1;
            } else {
                // Generate New Map
                currentMapLayout = generateMaze(STATE.level);
            }
            
            updateUI();
        }

        function updateUI() {
            levelDisplay.innerText = `Level: ${STATE.level}`;
            if (STATE.isFlipped) {
                modeDisplay.innerText = "Mode: NEURO-SWITCH (FLIPPED)";
                modeDisplay.className = "mode-indicator mode-flipped";
                player.color = "#f43f5e"; // Red/Pink for danger/hard
            } else {
                modeDisplay.innerText = "Mode: MOTOR ACQUISITION";
                modeDisplay.className = "mode-indicator mode-normal";
                player.color = "#38bdf8"; // Blue for calm/learning
            }
        }

        // --- RENDERING ---

        function drawMap() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall-color');
            
            for(let y=0; y<STATE.rows; y++) {
                for(let x=0; x<STATE.cols; x++) {
                    if(currentMapLayout[y][x] === 1) {
                        ctx.fillRect(x * STATE.gridSize, y * STATE.gridSize, STATE.gridSize, STATE.gridSize);
                    }
                }
            }
        }

        function drawEntities() {
            // Draw Goal
            ctx.fillStyle = goal.color;
            // Add a little pulse effect
            const pulse = Math.sin(Date.now() / 200) * 2;
            ctx.fillRect(
                goal.x * STATE.gridSize + 2 - pulse/2, 
                goal.y * STATE.gridSize + 2 - pulse/2, 
                STATE.gridSize - 4 + pulse, 
                STATE.gridSize - 4 + pulse
            );

            // Draw Player
            ctx.fillStyle = player.color;
            const size = STATE.gridSize * 0.7;
            const offset = (STATE.gridSize - size) / 2;
            
            // Interpolated position for smoothness (simple here)
            ctx.fillRect(
                player.x * STATE.gridSize + offset, 
                player.y * STATE.gridSize + offset, 
                size, 
                size
            );

            // Draw "Eyes" to indicate direction (helps visualize the flip)
            ctx.fillStyle = "white";
            // Logic to draw eyes based on last movement could go here, 
            // but abstract square is better for neuro-focus.
        }

        function render() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw
            drawMap();
            drawEntities();

            // Loop
            handleInput();
            requestAnimationFrame(render);
        }

        // Start
        initGame();

    </script>
</body>
    </html>
